<meta charset="utf-8">
<style>

#page {
  height: 100%; width: 100%
}

.slider
{
    width: 50%;
}

#map-canvas 
{ 
	height: 100%;
}

#map_td
{
	height: 100%;
}

</style>

<table id="page">


<tr><td id="map_td">
<div id="map-canvas"></div><P>
</td></tr>

<tr><td>
<!-- <canvas id="canvas" style="border:1px solid #000000;"></canvas><P> -->
<canvas id="canvas" ></canvas><P>
</td></tr>

<tr><td>
<div id="controls">
<font face=helvetica><b>
<TT>Highlighted: <output id="highlightRange"></output><BR>
Pointer: <output id="pointerRange"></output><BR>

<!-- Constrain: -->
<!-- <input onClick="constrainEvent()" type="radio" id="constrainTime" name="constrain" value="time">Time -->
<!-- <input onClick="constrainEvent()" type="radio" id="constrainDistance" name="constrain" value="distance">Distance -->


<input onClick="heatMapEvent()" type="checkbox" id="heatmap" name="heatmap" value="0">
Heat map  Time: 
<input onClick="timeEvent()" type="radio" id="absoluteTime" name="time" value="absolute">Absolute 
<input onClick="timeEvent()" type="radio" id="elapsedTime" name="time" value="elapsed">Elapsed<BR> 


<div id="file_inputs">
<input type="file" id="file" />
<button onClick="analyzeFile()">Analyze local file</button><BR>

<input type="url" id="url" />
<button onClick="analyzeURL()" >Analyze URL</button><BR>
</div>




<!-- X Zoom: -->
<!-- <input type="range" id="xzoom" class="slider" onchange="handleZoomX(value)"> -->
<!-- <button onClick="zoomXFit()">Fit</button><BR> -->

Smoothing: 
<input type="range" max="100" id="averaging" class="slider" onchange="handleSmoothing(value)">
<output id="smoothingText"></output><BR>

</td></tr>
</div>
</table>


<script type="text/javascript" src="https://maps.googleapis.com/maps/api/js?key=AIzaSyDOOyShdCyx800OrbhmAl9cQniQdxLTSkk&sensor=FALSE">
</script>

<script src="jquery-2.1.1.min.js"></script>

<script>

// classes
	function LLH(latitude, longitude, altitude)
	{
		this.latitude = latitude;
		this.longitude = longitude;
		this.altitude = altitude;
	}

	function XYZ(x, y, z)
	{
		this.x = x;
		this.y = y;
		this.z = z;
	}


	function GraphSlot(point, pace, altitude)
	{
		this.point = point;
		this.pace = pace;
		this.altitude = altitude;
	}


	function RoutePoint(llh, xyz, time, elapsed, distance)
	{
		this.llh = llh;
// meters
		this.xyz = xyz;
// absolute time in seconds
		this.time = time;
// elapsed time in second
		this.elapsed = elapsed;
// accumulated distance in meters
		this.distance = distance;

	}


// get the time of the point, based on timeFormat
	RoutePoint.prototype.getTime = function() {
		if(timeFormat == ABSOLUTE_TIME)
		{
			return this.time - route[0].time;
		}
		else
		{
			return this.elapsed  - route[0].elapsed;
		}
	};
	
	
// variables
	var mapLatitude = 37.78686;
	var mapLongitude = -122.351089;
	var mapZoom = 15;
	var mapMode = google.maps.MapTypeId.SATELLITE;

// raw data
	var route = new Array();
// averaged speed & altitude of complete route
	var graphData = new Array();
// extents of graph
    var graphX1 = 0
    var graphX2 = 0
    var graphW = 0
	var highlightPolygons = new Array()
	var pathPolygons = new Array()
	var cursorMarker = null;
// starting route slot of view
	var minIndex = 0;
// ending route slot of view
	var maxIndex = 1;
// span to measure pace in seconds
	var smoothingTime = 60;
// in miles
	var smoothingDistance = 0.25;
	var MAX_SMOOTHING_DISTANCE = 1.0;
	var MAX_SMOOTHING_TIME = 120;
// how to constrain the highlight size & smoothing
	var FIXED_DISTANCE = 0;
	var FIXED_TIME = 1;
	var constrain = FIXED_DISTANCE;
    
    var heatmapToggle = document.getElementById("heatmap")
    var isHeatmap = false
    
	var ABSOLUTE_TIME = 0;
	var ELAPSED_TIME = 1;
	var timeFormat = ABSOLUTE_TIME;
	var documentMinPace = 0;
	var documentMaxPace = 100;
// absolute max pace in seconds
	var ABS_MAX_PACE = 30 * 60;
	var ABS_MIN_PACE = 5 * 60;
	var minPace = 6 * 60;
	var maxPace = 24 * 60;
	var documentMinAlt = 0;
	var documentMaxAlt = 100;
	var minAlt = 0;
	var maxAlt = 300;
// last click was in canvas
	var isCanvas = false;
	var isDragging = false;
	var isDraggingStart = false;
	var isDraggingEnd = false;
	var isDraggingMid = false;
	var isTrackingCursor = false;
	var cursorIndex = 0;
// starting pixel of a drag
	var dragOffsetX = 0;
	var dragOffsetY = 0;
// starting extents of a drag
	var dragMinX = 0;
	var dragMaxX = 0;
// default value for URL box
	var defaultURL = "";
// seconds of waveform selected
	var highlightBegin = 0;
	var highlightEnd = 1;
	var dragHighlightBegin = 0;
	var dragHighlightEnd = 1;
	var dragHighlightLength = 0;
// calculated in drawGraph
	var altScale = 0;
	var paceScale = 0;
	var highlightBeginX = 0;
	var highlightEndX = 0;
// time in milliseconds considered a double click
	var DOUBLECLICKMS = 500;
// time in milliseconds since last click
	var doubleClickTime = 0;

// default sizes
	var canvas = document.getElementById("canvas");
	var RIGHT_MARGIN = 20;
	var CANVAS_HEIGHT = 220;
	var FIELD_HEIGHT = 200;
	var TIME_HEIGHT = 20;
	var FONT_HEIGHT = 14;
	var FONT_MARGIN = 2;
	var HIGHLIGHT_SIZE = 20;
	var WAVEFORM_HEIGHT = CANVAS_HEIGHT - FONT_HEIGHT - FONT_MARGIN;
	var POINTER_SIZE = 10;
// meters
	var DISTANCE_INCREMENT = 10;
    var M_TO_MI = 1609.36357
// the map
	var map;
	var boundaries = new google.maps.LatLngBounds();
	
	canvas.width = window.innerWidth - RIGHT_MARGIN;
	canvas.height = CANVAS_HEIGHT;

	canvas.addEventListener("DOMMouseScroll",	
		mouseScroll,
		false);
	canvas.addEventListener("mousewheel",	
		mouseScroll,
		false);
	window.addEventListener("resize", resizeEvent, false);
	document.getElementById("file").addEventListener("change", handleFileSelect, false);

	function metersToMiles(x)
	{
		return x / M_TO_MI;
	}

	function milesToMeters(x)
	{
		return x * M_TO_MI;
	}

    function initializeMap() 
	{
      	var mapOptions = 
	  	{
        	center: new google.maps.LatLng(mapLatitude, mapLongitude),
        	zoom: mapZoom,
			mapTypeId: mapMode
      	};
      
	  	map = new google.maps.Map(document.getElementById("map-canvas"),
          	mapOptions);

		google.maps.event.addListener(map, 'click', function(e) {
			lensLatitude = e.latLng.lat();
			lensLongitude = e.latLng.lng();
			saveDefaults();
  		});

 		google.maps.event.addListener(map, 'center_changed', function() {
			mapLatitude = map.getCenter().lat();
			mapLongitude = map.getCenter().lng();
			mapZoom = map.getZoom();
			saveDefaults();
  		});

 		google.maps.event.addListener(map, 'maptypeid_changed', function() {
			mapMode = map.getMapTypeId();
			saveDefaults();
  		});
    }
	

	$(document).ready(function()
	{
		loadDefaults();
		updateZoom();
		drawGraph();
    	initializeMap();
		resizeEvent();
		
		var start = window.location.href.indexOf("?");
		var arg = null;
		if(start >= 0)
		{
			arg = window.location.href.substring(start + 1);
		}
	
	

		if(arg != null)
		{
			$(file_inputs).hide();
			analyzeURLArg(arg);
		}
		else
		{
			$(file_inputs).show();
		}
	})
	
// resize interface based on browser size
	function resizeEvent()
	{
		canvas.width = window.innerWidth - RIGHT_MARGIN;
		canvas.height = CANVAS_HEIGHT;
//		var mapCanvas = document.getElementById("map-canvas");
//		var controls = document.getElementById("controls");
//		var controlsStyle = window.getComputedStyle(controls, null);
//		var controlsH = parseInt(controlsStyle.getPropertyValue("height"));
//
//		debug("resizeEvent", 
//			" " + window.innerHeight);
//		mapCanvas.style.height = window.innerHeight - 
//			CANVAS_HEIGHT - 
//			controlsH -
//			64;
//		google.maps.event.trigger(map, "resize");
		drawGraph();
	}

	canvas.onmousedown = function(e)
	{
		var rect = canvas.getBoundingClientRect();
		var canvasX = e.clientX - rect.left;
		var canvasY = e.clientY - rect.top;

		var x = e.clientX;
		var y = e.clientY;
	
	
		isCanvas = true;
		
		debug("onmousedown", 
			"e.layerX=" + e.layerX + 
			" e.screenX=" + e.screenX +
			" e.offsetX=" + e.offsetX);
//		debug("onmousedown", "highlightBeginX=" + highlightBeginX);
	
		if(
//			(highlightEndX < highlightBeginX + graphX1 ||
//			highlightEndX - highlightBeginX + graphX1 > HIGHLIGHT_SIZE * 2.5) &&
			canvasX >= highlightBeginX + graphX1 - HIGHLIGHT_SIZE && 
			canvasX < highlightBeginX + graphX1 &&
			canvasY >= 0 && 
			canvasY < WAVEFORM_HEIGHT)
		{
			isDraggingStart = true;
			dragOffsetX = x;
			dragOffsetY = y;
			dragHighlightBegin = highlightBegin;
		}
		else
		if(
//			(highlightEndX < highlightBeginX + graphX1 ||
//			highlightEndX - highlightBeginX + graphX1 > HIGHLIGHT_SIZE * 2.5) &&
			canvasX < highlightEndX + graphX1 + HIGHLIGHT_SIZE && 
			canvasX >= highlightEndX + graphX1 &&
			canvasY >= 0 && 
			canvasY < WAVEFORM_HEIGHT)
		{
			isDraggingEnd = true;
			dragOffsetX = x;
			dragOffsetY = y;
			dragHighlightEnd = highlightEnd;
		}
		else
		if(canvasX >= highlightBeginX + graphX1 && 
			canvasX < highlightEndX + graphX1 &&
			canvasY >= WAVEFORM_HEIGHT - HIGHLIGHT_SIZE && 
			canvasY < WAVEFORM_HEIGHT)
		{
			isDraggingMid = true;
			dragOffsetX = x;
			dragOffsetY = y;
			dragHighlightBegin = highlightBegin;
			dragHighlightEnd = highlightEnd;
			dragHighlightLength = getAccumDistance(highlightBegin, highlightEnd);
		}
		else
		{
			isDragging = true;
			dragOffsetX = x;
			dragOffsetY = y;
			dragMinX = minIndex;
			dragMaxX = maxIndex;
		}
		
		debug("onmousedown", 
			" isDraggingStart=" + isDraggingStart +
			" isDraggingEnd=" + isDraggingEnd +
			" isDraggingMid=" + isDraggingMid +
			" isDragging=" + isDragging)

	}
	
	
	
	window.onmouseup = function(e)
	{
//		debug("onmouseup", e);
		if(isCanvas)
		{
			var newTime = new Date().getTime();
			if(newTime - doubleClickTime < DOUBLECLICKMS)
			{
				var rect = canvas.getBoundingClientRect();
// cursor position relative to canvas
				var canvasX = e.layerX - rect.left - graphX1;
				var canvasY = e.layerY - rect.top;
// cursor position relative to waveform
				var waveformX = canvasX * (maxIndex - minIndex) / graphW + minIndex;
// size of canvas relative to waveform
				var zoomX = maxIndex - minIndex;
				
				if(e.ctrlKey)
					zoomX *= 2;
				else
					zoomX /= 2;
				minIndex = waveformX - canvasX * zoomX / graphW;
				maxIndex = minIndex + zoomX;
				redraw(false);
				doubleClickTime = 0;
				
			}
			else
			{
				doubleClickTime = newTime;
			}
			
		}


		isCanvas = false;
		isDragging = false;
		isDraggingStart = false;
		isDraggingEnd = false;
		isDraggingMid = false;
	}
	
	window.onkeypress = function(e)
	{
		debug("onkeypress", "e.keyCode=" + e.keyCode);
		if(e.keyCode == 43 || e.keyCode == 61)
		{
			var centerX = (maxIndex + minIndex) / 2;
// size of canvas relative to waveform
			var zoomX = maxIndex - minIndex;
			zoomX /= 2;

			minIndex = centerX - zoomX / 2;
			maxIndex = centerX + zoomX / 2;
		
			redraw(false);
		}
		else
		if(e.keyCode == 45)
		{
			var centerX = (maxIndex + minIndex) / 2;
// size of canvas relative to waveform
			var zoomX = maxIndex - minIndex;
			zoomX *= 2;

			minIndex = centerX - zoomX / 2;
			maxIndex = centerX + zoomX / 2;
		
			redraw(false);
		}
	}
	
	canvas.ondragover = function()
	{
		debug("ondrag", "");
	}
	
	window.onmousemove = function(e)
	{
		var x = e.clientX;
		var y = e.clientY;
//		debug("onmousemove", "x=" + x + " y=" + y);

// drag highlighted area		
		if(isDraggingStart)
		{
			var diffX = x - dragOffsetX;
			var diffSamples = diffX * (maxIndex - minIndex) / canvas.width;
			highlightBegin = dragHighlightBegin + diffSamples;
			redraw(false);
			updateOutput();
			drawMap(false, true, true);
		}
		else
		if(isDraggingEnd)
		{
			var diffX = x - dragOffsetX;
			var diffSamples = diffX * (maxIndex - minIndex) / canvas.width;
			highlightEnd = dragHighlightEnd + diffSamples;
			redraw(false);
			updateOutput();
			drawMap(false, true, true);
		}
		else
		if(isDraggingMid)
		{
			var diffX = x - dragOffsetX;
			var diffSamples = diffX * (maxIndex - minIndex) / canvas.width;
			highlightBegin = dragHighlightBegin + diffSamples;
			highlightEnd = dragHighlightEnd + diffSamples;
// calculate new ending point based on highlighted distance
			if(highlightBegin < route.length && 
				highlightBegin >= 0 && 
				route.length > 0 &&
				constrain == FIXED_DISTANCE)
			{
				var point1 = route[Math.floor(highlightBegin)];
				var accum = 0;
				for(var i = Math.floor(highlightBegin) + 1; 
					i < route.length; 
					i++)
				{
					var point2 = route[i];
// meters
					var distance = getDistance(point2.xyz, point1.xyz);
					if(distance >= DISTANCE_INCREMENT)
					{
						accum += distance;
						point1 = point2;
						if(accum >= dragHighlightLength)
						{
							highlightEnd = i;
							break;
						}
					}
				}
			}
			redraw(false);
			updateOutput();
			drawMap(false, true, true);
		}
		else
		if(isDragging)
		{
//			debug("onmousemove", 
//				"e.layerX=" + e.layerX + 
//				" e.screenX=" + e.screenX +
//				" e.offsetX=" + e.offsetX);
			var diffX = x - dragOffsetX;
			var diffSamples = diffX * (dragMaxX - dragMinX) / canvas.width;
			
			minIndex = dragMinX - diffSamples;
			maxIndex = dragMaxX - diffSamples;
//			debug("onmousemove", "diffX=" + diffX + " diffSamples=" + diffSamples + " dragMinX=" + dragMinX + " dragMaxX=" + dragMaxX + " minIndex=" + minIndex + " maxIndex=" + maxIndex);
//			debug("onmousemove", "minY=" + minY + " maxY=" + maxY);
			redraw(false);
		}
		else
		{
// cursor position relative to canvas
			var rect = canvas.getBoundingClientRect();
			x -= rect.left;
			y -= rect.top;

// 			debug("onmousemove", 
// 				" x=" + x + 
// 				" y=" + y +
// 				" canvas.width=" + canvas.width +
// 				" canvas.height=" + canvas.height)
			if(x >= graphX1 && x < graphX2 && y >= 0 && y < canvas.height)
			{
				isTrackingCursor = true;
				cursorIndex = Math.floor(x - graphX1);
				drawGraph();
				updateOutput();
				drawMap(false, false, true);
			}
			else
			{
				if(isTrackingCursor)
				{
					isTrackingCursor = false;
					drawGraph();
					
				}
			}
		}
	}
	
	function mouseScroll(e)
	{
		var change = e.wheelDelta || -e.detail;
// cursor position relative to canvas
		var rect = canvas.getBoundingClientRect();
		var x = e.layerX - rect.left;
		var y = e.layerY - rect.top;
// cursor position relative to waveform
		var cursorIndex = x * (maxIndex - minIndex) / canvas.width + minIndex;
// size of canvas relative to waveform
		var zoomX = maxIndex - minIndex;


//		debug("mouseScroll", 
//			"e.layerX=" + e.layerX + 
//			" e.screenX=" + e.screenX +
//			" e.offsetX=" + e.offsetX);


		if(change > 0)
		{
			zoomX /= 2;
		}
		else
		{
			zoomX *= 2;
		}
		
		minIndex = cursorIndex - x * zoomX / canvas.width;
		maxIndex = minIndex + zoomX;
		
		redraw(false);
		
//		debug("mouseScroll", change);
	}

	function debug(where, text)
	{
		console.log(where + ": " + text);
//    	setTimeout(function() {
//        	throw new Error(where + ": " + text);
//    	}, 0);
	}

//		document.getElementById("text").innerHTML += where + ": " + text + "<br>";
//	}
	
	function redraw(needData)
	{
		var time1 = new Date().getTime();
		clampGraph();
		
		if(needData) calculateGraph();
		drawGraph();
		updateZoom();
        drawMap(needData, needData, true)
		
		var time2 = new Date().getTime();
//		debug("redraw", time2 - time1 + "ms");
	}
	
	function clampGraph()
	{
		minPace = clamp(minPace, documentMinPace, documentMaxPace);
		maxPace = clamp(maxPace, documentMinPace, documentMaxPace);
		minAlt = clamp(minAlt, documentMinAlt, documentMaxAlt);
		maxAlt = clamp(maxAlt, documentMinAlt, documentMaxAlt);
		if(maxIndex - minIndex < 10) maxIndex = minIndex + 10;
		if(smoothingTime < 1) smoothingTime = 1;
		if(smoothingDistance < 0.01) smoothingDistance = 0.01;
//		if(maxIndex - minIndex > route.length)
//		{
//			maxIndex = minIndex + route.length;
//		}
		
	}
	
	function handleZoomX(value)
	{
		var centerX = (maxIndex + minIndex) / 2;
		var zoom = route.length * value / 100;
		minIndex = centerX - zoom / 2;
		maxIndex = centerX + zoom / 2;
		clampGraph();
		saveDefaults();
		redraw(false);
	}
	
	function handleSmoothing(value)
	{
		if(constrain == FIXED_DISTANCE)
		{
			smoothingDistance = value * MAX_SMOOTHING_DISTANCE / 100;
		}
		else
		{
			smoothingTime = value * MAX_SMOOTHING_TIME / 100;
		}
		
		clampGraph();
		saveDefaults();
		redraw(true);
	}
	
	

	function zoomXFit()
	{
		minIndex = 0;
		maxIndex = route.length;
		saveDefaults();
		updateZoom();
		redraw(false);
	}
		
	


// update zoom parameters
	function updateZoom()
	{
// browsers don't allow setting the default file
//debug("updateZoom", "url=" + defaultURL);
		document.getElementById("url").value = defaultURL;
		if(constrain == FIXED_DISTANCE)
		{
			document.getElementById("averaging").value = 
				smoothingDistance * 
				100 /
				MAX_SMOOTHING_DISTANCE;
			document.getElementById("smoothingText").innerHTML = 
				smoothingDistance + "mi";
		}
		else
		{
			document.getElementById("averaging").value = 
				smoothingTime *
				100 /
				MAX_SMOOTHING_TIME;
			document.getElementById("smoothingText").innerHTML = 
				smoothingTime + "s";
		}

//		document.getElementById("xzoom").value = (maxIndex - minIndex) * 100 / route.length;

//debug("updateZoom", "constrain=" + constrain);
// 		switch(constrain)
// 		{
// 			case FIXED_TIME:
// 				document.getElementById("constrainDistance").checked = false;
// 				document.getElementById("constrainTime").checked = true;
// 				break;
// 			case FIXED_DISTANCE:
// 				document.getElementById("constrainDistance").checked = true;
// 				document.getElementById("constrainTime").checked = false;
// 				break;
// 		}

        heatmapToggle.checked = isHeatmap


		switch(timeFormat)
		{
			case ABSOLUTE_TIME:
				$(elapsedTime).prop("checked", false);
				$(absoluteTime).prop("checked", true);
				break;
			case ELAPSED_TIME:
				$(elapsedTime).prop("checked", true);
				$(absoluteTime).prop("checked", false);
				break;
		}

//		document.getElementById("min_alt").value = (minAlt - documentMinAlt) * 100 / (documentMaxAlt - documentMinAlt);
//		document.getElementById("max_alt").value = (maxAlt - documentMinAlt) * 100 / (documentMaxAlt - documentMinAlt);
//		document.getElementById("min_pace").value = (minPace - documentMinPace) * 100 / (documentMaxPace - documentMinPace);
//		document.getElementById("max_pace").value = (maxPace - documentMinPace) * 100 / (documentMaxPace - documentMinPace);
	}

// get accumulated distance between 2 points in meters
	function getAccumDistance(begin, end)
	{
		begin = Math.floor(begin);
		end = Math.floor(end);
		var point1 = route[begin];
		var accum = 0;
		for(var i = begin + 1; i < end; i++)
		{
			var point2 = route[i];
// meters
			var distance = getDistance(point2.xyz, point1.xyz);
			if(distance >= DISTANCE_INCREMENT)
			{
				accum += distance;
				point1 = point2;
			}
		}
		return accum;
	}

// get the time of the point, based on timeFormat
	function pointTime(index)
	{
		if(timeFormat == ABSOLUTE_TIME)
		{
			return route[index].time;
		}
		else
		{
			return route[index].elapsed  - route[0].elapsed;
		}
	}
	
	function updateOutput()
	{
		if(route.length == 0) return;
		
		var start = Math.floor(clamp(highlightBegin, 0, route.length - 1));
		var end = Math.floor(clamp(highlightEnd, 0, route.length - 1));
//		debug("updateOutput", "start=" + start + " end=" + end);
		var point1 = route[start];
		var point2 = route[end];
// accumulated distance in meters
		var distance = point2.distance - point1.distance;

		var time = point2.getTime() - point1.getTime();
		var altitude = point2.llh.altitude - point1.llh.altitude;
// meters -> ft
		altitude = altitude * 3.2808;
		var pace = 0;
			
// seconds per mile
		if(distance >= 1)
			pace = time * M_TO_MI / distance;
// meters -> miles
		distance = distance / M_TO_MI;
		
		document.getElementById("highlightRange").innerHTML = 
			Math.floor(distance * 100) / 100 + "miles " +
			Math.floor(time / 3600) + "h" + Math.floor((time % 3600) / 60) + "m" + Math.floor(time % 60) + "s total " +
			Math.floor(pace / 60) + "m" + Math.floor(pace % 60) + "s per mile " +
			Math.floor(altitude) + "ft change";
		
		if(isTrackingCursor)
		{
			var subscript = cursorIndex * (maxIndex - minIndex) / canvas.width + minIndex;
			var result = xToPaceAltitude(cursorIndex);
			var distance = 0;
			
			if(subscript >= 0 && subscript < route.length)
			{
				var point = route[Math.floor(subscript)];
				distance = point.distance;
// meters -> miles
				distance = distance / M_TO_MI;
				time = point.getTime();
			}
			
			document.getElementById("pointerRange").innerHTML = 
				Math.floor(time / 3600) + "h" + Math.floor((time % 3600) / 60) + "m" + Math.floor(time % 60) + "s " +
				Math.floor(distance * 100) / 100 + "miles total " + 
				Math.floor(result.pace / 60) + "m" + Math.floor(result.pace % 60) + "s per mile " +
				Math.floor(result.altitude) + "ft";
		}
	}

	function square(x)
	{
		return x * x;
	}
	
	function clamp(x, min, max)
	{
		if(x > max) x = max;
		if(x < min) x = min;
		return x;
	}
	
	function getDistance(xyz1, xyz2)
	{
		return Math.sqrt(square(xyz1.x - xyz2.x) + 
			square(xyz1.y - xyz2.y) +
			square(xyz1.z - xyz2.z));
	}

// http://www.oc.nps.edu/oc2902w/coord/llhxyz.htm
 	function radcur(EARTH_A, EARTH_B, lati)
 	/*
 	   compute the radii at the geodetic latitude lat (in degrees)
 	   input:  lat       geodetic latitude in degrees
 	   output: rrnrm     an array 3 long
 	                     r,  rn,  rm   in km
 	*/
 	{
 		var dtr   = Math.PI / 180.0;

 		var  a, b, lat;
 		var  asq, bsq, eccsq, ecc, clat, slat;
 		var  dsq, d, rn, rm, rho, rsq, r, z;

 	   //        -------------------------------------

 		a     = EARTH_A;
 		b     = EARTH_B;

 		asq   = a * a;
 		bsq   = b * b;
 		eccsq  =  1.0 - bsq / asq;
 		ecc = Math.sqrt(eccsq);

 		lat   =  lati;

 		clat  =  Math.cos(dtr * lat);
 		slat  =  Math.sin(dtr * lat);

 		dsq   =  1.0 - eccsq * slat * slat;
 		d     =  Math.sqrt(dsq);

 		rn    =  a / d;
 		rm    =  rn * (1.0 - eccsq ) / dsq;

 		rho   =  rn * clat;
 		z     =  (1.0 - eccsq ) * rn * slat;
 		rsq   =  rho * rho + z * z;
 		r     =  Math.sqrt( rsq );

		
 		this.rrnrm = [ r, rn, rm ];




 	}



	function llhToXYZ(llh)
	{
// convert altitude to km from m
// 		var altitude = llh.altitude / 1000;
// ignore altitude for distance calculations
 		var altitude = 0;

//		document.getElementById("text").innerHTML += latitude + " " + longitude + " " + altitude + "<P>";
		
		
 		// used by distance calculation	
 		var EARTH_A;
 		var EARTH_B;
 		var EARTH_F;
 		var EARTH_Ecc;
 		var EARTH_Esq;

 		
 	// Earth constants
 	    var wgs84a, wgs84b, wgs84f;

 	    wgs84a = 6378.137;
 	    wgs84f = 1.0 / 298.257223563;
 	    wgs84b = wgs84a * ( 1.0 - wgs84f );


 		var  f, ecc, eccsq, a, b;

 	    a        =  wgs84a;
 	    b        =  wgs84b;

 	    f        =  1 - b / a;
 	    eccsq    =  1 - b * b / (a * a);
 	    ecc      =  Math.sqrt(eccsq);

 	    EARTH_A   = a;
 	    EARTH_B   = b;
 	    EARTH_F   = f;
 	    EARTH_Ecc = ecc;
 	    EARTH_Esq = eccsq;

 		
 	    var dtr =  Math.PI / 180.0;
 	    var flat, flon;
 	    var clat, clon, slat, slon;
 	    var rn, esq;

 	    clat = Math.cos(dtr * llh.latitude);
 	    slat = Math.sin(dtr * llh.latitude);
 	    clon = Math.cos(dtr * llh.longitude);
 	    slon = Math.sin(dtr * llh.longitude);

 	    var rrnrm = new radcur(EARTH_A, EARTH_B, llh.latitude).rrnrm;
 	    rn = rrnrm[1];
 	    var re = rrnrm[0];

 	    ecc = EARTH_Ecc;
 	    esq = ecc * ecc;

//		document.getElementById("text").innerHTML += "rn=" + rn + "<P>";


		this.xyz = new XYZ();
 	    this.xyz.y = (rn + altitude) * 
 			clat * 
 			slon;
 	    this.xyz.x = (rn + altitude) * 
 			clat * 
 			clon;
 	    this.xyz.z = ( (1 - esq) * rn + altitude ) * slat;

 	    this.xyz.x *= 1000;
 	    this.xyz.y *= 1000;
 	    this.xyz.z *= 1000;
		
	}


	function paceToPixel(pace)
	{
// linear scale
//		return (pace - minPace) * paceScale;
// logarithmic scale
		if(pace < minPace + 1) return 0;
		if(pace > maxPace) return WAVEFORM_HEIGHT;

		var maxLog = Math.log(1 / (maxPace - minPace));
		var result = Math.log((pace - minPace) / (maxPace - minPace)) / maxLog;
		result = WAVEFORM_HEIGHT - result * WAVEFORM_HEIGHT;
//		debug("paceToPixel", " result=" + result);
		return result;
	}
	
    function paceToHue(pace)
    {
        if(pace < minPace + 1) return 300
        if(pace > maxPace) return 240
        
        var maxLog = Math.log(1 / (maxPace - minPace));
        var result = Math.log((pace - minPace) / (maxPace - minPace)) / maxLog;
        
        var result = 240 - result * 300
        if(result < 0)
        {
            result += 360
        }
        
//        console.log("pace=" + pace + " hue=" + result)
        return result
    }

	function paceToText(pace)
	{
		if(pace < 60) return pace + "s";
		var result = Math.floor(pace / 60) + "m";
		if(Math.floor(pace % 60) > 0) result += Math.floor(pace % 60) + "s";
		return result;
	}
    
    function distanceToText(distance)
    {
        var distance = Math.floor(distance * 100) / 100
        return distance.toString()
    }
	
	function altToText(alt)
	{
		return Math.floor(alt) + "ft";
	}
	
	function altToPixel(alt)
	{
		return WAVEFORM_HEIGHT - (alt - minAlt) * altScale;
	}

	function xToPaceAltitude(x)
	{
		var subscript1 = Math.floor(x * (maxIndex - minIndex) / graphW + minIndex);
		var subscript2 = Math.floor((x + 1) * (maxIndex - minIndex) / graphW + minIndex);
		if(subscript1 >= graphData.length) subscript1 = graphData.length - 1;
		if(subscript1 < 0) subscript1 = 0;
		if(subscript2 >= graphData.length) subscript2 = graphData.length - 1;
		if(subscript2 < 0) subscript2 = 0;

//			debug("drawGraph", "subscript1=" + subscript1);

		var pace = 0;
		var altitude =  0;

		if(subscript2 > subscript1)
		{
			pace = 99999;
			for(var j = subscript1; j < subscript2; j++)
			{
				var slot = graphData[Math.floor(j)];
				if(slot.pace < pace) pace = slot.pace;
				if(slot.altitude > altitude) altitude = slot.altitude;
//						pace += slot.pace;
//						altitude += slot.altitude;
			}

//					pace /= subscript2 - subscript1;
//					altitude /= subscript2 - subscript1;
		}
		else
		{
			var slot = graphData[Math.floor(subscript1)];
			pace = slot.pace;
			altitude = slot.altitude;
		}

// Chrome interprets the line feed wrong
		return {
	        pace : pace,
    	    altitude : altitude
		};
    };  
		

	function calculateGraph()
	{
		graphData = new Array();
		var gotStart = false;
		var index0 = 0;
		var smoothingMeters = milesToMeters(smoothingDistance);

// get starting point
		if(constrain == FIXED_DISTANCE)
		{
			for(var i = 0; i < route.length; i++)
			{
				var point = route[i];

				if(point.distance >= smoothingMeters)
				{
					index0 = i;
					gotStart = true;
					break;
				}
			}
		}
		else
		{
			index0 = smoothingTime;
			gotStart = true;
		}

		if(gotStart)
		{
			for(var i = index0; i < route.length; i++)
			{
				var point1 = null;
				var point2 = route[i];
				var	index1 = 0;
				var index2 = i;
				if(constrain == FIXED_TIME)
				{
					index1 = i - smoothingTime;
				}
				else
				{
					for(var j = i; j >= 0; j--)
					{
						var point = route[j];
						if(point2.distance - point.distance >= smoothingMeters)
						{
							index1 = j;
							break;
						}
					}
				}

				point1 = route[index1];


	// meters
				var distance = point2.distance - point1.distance;
	// seconds
				var time = point2.getTime() - point1.getTime();
	// seconds per mile
				var pace = 0;

				if(distance >= 1)
				{
// calculate new pace
					pace = time * M_TO_MI / distance;
				}
				else
				if(graphData.length > 0)
				{
// recycle previous point
					pace = graphData[graphData.length - 1].pace;
				}

				var altitude = 0;
				for(var j = index1; j < index2; j++)
				{
					altitude += route[j].llh.altitude;
				}
				
				
				
// averaged meters -> ft
				if(index2 > index1)
				{
					altitude = altitude * 3.2808 / (index2 - index1);
				}
				else
				{
					altitude = route[index2].llh.altitude * 3.2808;
				}

// fill in 1st points
				if(i == index0)
				{
					for(var j = 0; j < index0; j++)
					{
						var slot = new GraphSlot(route[j], pace, altitude);
						graphData.push(slot);
					}
				}

				var slot = new GraphSlot(point2, pace, altitude);
				graphData.push(slot);
	//			debug("calculateGraph", "distance=" + distance + " time=" + time + " pace=" + pace);
			}
		}


// get Y limits
		documentMinPace = 99999;
		documentMaxPace = -99999;
		documentMinAlt = 99999;
		documentMaxAlt = -99999;
		for(var i = 0; i < graphData.length; i++)
		{
			var slot = graphData[i];
			if(slot.pace > 0)
			{
				if(slot.pace < documentMinPace) documentMinPace = slot.pace;
				if(slot.pace > documentMaxPace) documentMaxPace = slot.pace;
			}
			if(slot.altitude < documentMinAlt) documentMinAlt = slot.altitude;
			if(slot.altitude > documentMaxAlt) documentMaxAlt = slot.altitude;
		}

		documentMaxPace = clamp(documentMaxPace, ABS_MIN_PACE, ABS_MAX_PACE);
		documentMinPace = clamp(documentMinPace, ABS_MIN_PACE, ABS_MAX_PACE);
		clampGraph();

		minPace = documentMinPace;
		maxPace = documentMaxPace;
		minAlt = documentMinAlt;
		maxAlt = documentMaxAlt;
//		debug("calculateGraph", "length=" + graphData.length);
//		debug("calculateGraph", "documentMinPace=" + documentMinPace + " documentMaxPace=" + documentMaxPace);
//		debug("calculateGraph", "documentMinAlt=" + documentMinAlt + " documentMaxAlt=" + documentMaxAlt);
	}
    

	function drawMap(doPath, doHighlight, doCursor)
	{
//	    console.log("drawMap doPath=" + doPath + " doHighlight=" + doHighlight + " doCursor=" + doCursor)
		
		if(doPath)
		{
// erase the existing polygons
			if(pathPolygons.length != 0)
			{
                for(var i = 0; i < pathPolygons.length; i++)
				{
                    pathPolygons[i].setMap(null);
				    pathPolygons[i] = null;
                }
                pathPolygons.length = 0
			}

            if(!isHeatmap)
            {
			    if(route.length != 0)
			    {
				    var path = new Array()
				    for(var i = 0; i < route.length; i++)
				    {
					    var point = route[i]
					    path.push(new google.maps.LatLng(
						    point.llh.latitude,
						    point.llh.longitude));
				    }

				    var poly = new google.maps.Polyline({
    				    path : path,
    				    geodesic : true,
    				    strokeColor : '#0000ff',
    				    strokeOpacity : 1.0,
    				    strokeWeight : 2,
					    zIndex : 0
				      });
				    poly.setMap(map);
                    pathPolygons.push(poly)
                }
            }
		}
		
		if(doHighlight)
		{

			if(highlightPolygons.length != 0)
			{
                for(var i = 0; i < highlightPolygons.length; i++)
				{
                    highlightPolygons[i].setMap(null);
				    highlightPolygons[i] = null;
                }
                highlightPolygons.length = 0
			}

			var start = Math.floor(clamp(highlightBegin, 0, route.length - 1));
			var end = Math.floor(clamp(highlightEnd, 0, route.length - 1));

// draw heatmap in highlighted region
            if(isHeatmap)
            {
                var point = route[start];
                var googPoint = new google.maps.LatLng(
						point.llh.latitude,
						point.llh.longitude)
                for(var i = start; i < end; i++)
                {
                    var pace = graphData[i].pace
                    var path = new Array();
                    path.push(googPoint);
                    point = route[i]
                    googPoint = new google.maps.LatLng(
						point.llh.latitude,
						point.llh.longitude)
                    path.push(googPoint);

                    var hue = paceToHue(pace)
				    var poly = new google.maps.Polyline({
    				    path : path,
    				    geodesic : true,
    				    strokeColor : 'hsl(' + hue + ', 100%, 50%)',
    				    strokeOpacity : 1.0,
    				    strokeWeight : 2,
					    zIndex : 0
				      });
				    poly.setMap(map);
                    highlightPolygons.push(poly)
                }
            }
            else
            {
			    if(route.length != 0)
			    {

// highlighted region
				    var path = new Array()
				    for(var i = start; i < end; i++)
				    {
					    var point = route[i];
					    path.push(new google.maps.LatLng(
						    point.llh.latitude,
						    point.llh.longitude));
				    }
				    var poly = new google.maps.Polyline({
    				    path: path,
    				    geodesic: true,
    				    strokeColor: '#ff0000',
    				    strokeOpacity: 1.0,
    				    strokeWeight: 2,
					    zIndex : 1
				      });
				    poly.setMap(map);
                    highlightPolygons.push(poly)
			    }
		    }
        }

		
		if(doCursor)
		{
			if(cursorMarker != null)
			{
				cursorMarker.setMap(null);
				cursorMarker = null;
			}
			
			if(isTrackingCursor && route.length > 0)
			{
				var subscript = cursorIndex * (maxIndex - minIndex) / graphW + minIndex;
				
				if(subscript < route.length && subscript >= 0)
				{
					var point = route[Math.floor(subscript)];

					cursorMarker = new google.maps.Marker({
    					position : new google.maps.LatLng(point.llh.latitude,
							point.llh.longitude)
					});
					cursorMarker.setMap(map);
				}
			}

		}


	}
	



	function dashedLine(ctx, x, y, x2, y2, da) 
	{
		ctx.beginPath();
        if (!da) da = [10,5];
        ctx.save();
        var dx = (x2-x), dy = (y2-y);
        var len = Math.sqrt(dx*dx + dy*dy);
        var rot = Math.atan2(dy, dx);
        ctx.translate(x, y);
        ctx.moveTo(0, 0);
        ctx.rotate(rot);       
        var dc = da.length;
        var di = 0, draw = true;
        x = 0;
        while (len > x) {
            x += da[di++ % dc];
            if (x > len) x = len;
            draw ? ctx.lineTo(x, 0): ctx.moveTo(x, 0);
            draw = !draw;
        }       
        ctx.restore();
		ctx.stroke();
    }

	function drawCross(ctx, x, y)
	{
		ctx.beginPath();
		ctx.moveTo(x - POINTER_SIZE, y - POINTER_SIZE);
		ctx.lineTo(x + POINTER_SIZE, y + POINTER_SIZE);
		ctx.stroke();
		ctx.beginPath();
		ctx.moveTo(x - POINTER_SIZE, y + POINTER_SIZE);
		ctx.lineTo(x + POINTER_SIZE, y - POINTER_SIZE);
		ctx.stroke();
		
	}

	function drawGraph()
	{
//		debug("drawGraph", "maxPace=" + maxPace + " minPace=" + minPace);
//		debug("drawGraph", "minAlt=" + minAlt + " maxAlt=" + maxAlt);
//		paceToPixel(500);
//		debug("drawGraph", "graphData.length=" + graphData.length);

		var time1 = new Date().getTime();
		altScale = WAVEFORM_HEIGHT / (maxAlt - minAlt);
		paceScale = WAVEFORM_HEIGHT / (maxPace - minPace);

		var ctx = canvas.getContext("2d"); 
		ctx.clearRect(0, 0, canvas.width, canvas.height);
        graphX1 = 0
        graphX2 = canvas.width
        
// make space for the heat map
        var HEATMAP_W = 10
        if(isHeatmap)
        {
            graphX1 = HEATMAP_W
        }
        graphW = graphX2 - graphX1

// highlighted region
		highlightBeginX = (highlightBegin - minIndex) * graphW / (maxIndex - minIndex);
		ctx.strokeStyle = "#c0c0c0";
		ctx.fillStyle = "#c0c0c0";
		ctx.lineWidth = '1'
		if(highlightBeginX >= 0 && 
			highlightBeginX < graphW + HIGHLIGHT_SIZE)
		{
			ctx.beginPath();
			ctx.moveTo(highlightBeginX + graphX1, 0);
			ctx.lineTo(highlightBeginX + graphX1, WAVEFORM_HEIGHT);
			ctx.stroke();
			ctx.beginPath();
			ctx.moveTo(highlightBeginX + graphX1 - HIGHLIGHT_SIZE, 0);
			ctx.lineTo(highlightBeginX + graphX1 - HIGHLIGHT_SIZE, WAVEFORM_HEIGHT);
			ctx.stroke();

			for(var i = 0; i < WAVEFORM_HEIGHT - HIGHLIGHT_SIZE; i += HIGHLIGHT_SIZE)
			{
				ctx.beginPath();
				ctx.moveTo(highlightBeginX + graphX1 - HIGHLIGHT_SIZE, i + HIGHLIGHT_SIZE);
				ctx.lineTo(highlightBeginX + graphX1, i);
				ctx.stroke();
			}


		}
		
		highlightEndX = (highlightEnd - minIndex) * 
			(graphW - 1) / 
			(maxIndex - minIndex);
		if(highlightEndX >= -HIGHLIGHT_SIZE && 
			highlightEndX < graphW)
		{
			ctx.beginPath();
			ctx.moveTo(highlightEndX + graphX1, 0);
			ctx.lineTo(highlightEndX + graphX1, WAVEFORM_HEIGHT);
			ctx.stroke();
			ctx.beginPath();
			ctx.moveTo(highlightEndX + graphX1 + HIGHLIGHT_SIZE, 0);
			ctx.lineTo(highlightEndX + graphX1 + HIGHLIGHT_SIZE, WAVEFORM_HEIGHT);
			ctx.stroke();


			for(var i = 0; i < WAVEFORM_HEIGHT - HIGHLIGHT_SIZE; i += HIGHLIGHT_SIZE)
			{
				ctx.beginPath();
				ctx.moveTo(highlightEndX + graphX1 + HIGHLIGHT_SIZE, i);
				ctx.lineTo(highlightEndX + graphX1, i + HIGHLIGHT_SIZE);
				ctx.stroke();
			}
		}
		
		ctx.beginPath();
		ctx.moveTo(highlightBeginX + graphX1, WAVEFORM_HEIGHT - HIGHLIGHT_SIZE);
		ctx.lineTo(highlightEndX + graphX1, WAVEFORM_HEIGHT - HIGHLIGHT_SIZE);
		ctx.stroke();
		for(var i = highlightBeginX + graphX1; 
            i < highlightEndX + graphX1 - HIGHLIGHT_SIZE; 
            i += HIGHLIGHT_SIZE)
		{
			ctx.beginPath();
			ctx.moveTo(i, WAVEFORM_HEIGHT - HIGHLIGHT_SIZE);
			ctx.lineTo(i + HIGHLIGHT_SIZE, WAVEFORM_HEIGHT);
			ctx.stroke();
		}


// pace scale
		ctx.lineWidth = '1'
		ctx.fillStyle = "#FF0000";
		ctx.strokeStyle = "#FF0000";
		ctx.textAlign = "left";
		ctx.font = "14px sans-serif";
		ctx.fillText(paceToText(minPace), 
            graphX1, 
            FONT_HEIGHT);
		ctx.fillText(paceToText(maxPace), 
            graphX1, 
            WAVEFORM_HEIGHT - FONT_MARGIN);

        var paceDivisions = [
            15,
            30,
            60,
            120,
            180
        ]
        var paceRounded = Math.floor(minPace / 60) * 60
        for(var i = 0; i < paceDivisions.length; i++)
        {
    		var pace1 = paceRounded + paceDivisions[i];
		    var y = paceToPixel(pace1);
		    if(y > FONT_HEIGHT * 2 && 
			    y < canvas.height - FONT_HEIGHT - FONT_MARGIN)
		    {
			    dashedLine(ctx, graphX1, y, graphX2, y, [5, 5]);
			    ctx.fillText(paceToText(pace1), graphX1, y - FONT_MARGIN);
		    }
        }
		
		
// altitude scale
		ctx.fillStyle = "#0000ff";
		ctx.strokeStyle = "#0000ff";
		ctx.textAlign = "right";
		ctx.fillText(altToText(maxAlt), graphX2 - FONT_MARGIN, FONT_HEIGHT);
		ctx.fillText(altToText(minAlt), graphX2 - FONT_MARGIN, WAVEFORM_HEIGHT - FONT_MARGIN);
		
		var step = 50;
		while((maxAlt - minAlt) / step > 4) step += 50;
		for(var i = Math.floor(maxAlt / step) * step + step; 
			i > minAlt; 
			i -= step)
		{
			y = altToPixel(i);
			if(y > FONT_HEIGHT * 2 && y < canvas.height - FONT_HEIGHT - FONT_MARGIN)
			{
				ctx.fillText(altToText(i), graphX2 - FONT_MARGIN, y - FONT_MARGIN);
				dashedLine(ctx, graphX2, y, graphX1, y, [5, 5]);
			}
		}

		if(graphData.length == 0) return;



// distance scale
        var distance1 = 0
        var x1 = graphX1
		ctx.fillStyle = "#000000"
		ctx.strokeStyle = "#000000"


/// starting point
        if(minIndex >= 0)
        {
            if(minIndex < route.length)
            {
                var point = route[Math.floor(minIndex)]
                distance1 = point.distance
            }
        }
        else
        if(minIndex < 0 && route.length > 0)
        {
            var point = route[0]
            distance1 = point.distance
            x1 = graphX1 + (-minIndex * graphW / (maxIndex - minIndex))
        }

		ctx.textAlign = "left"
		ctx.fillText(distanceToText(distance1 / M_TO_MI), 
            x1, 
            CANVAS_HEIGHT - FONT_MARGIN)

// ending point
        var distance2 = 0
        var x2 = graphX2
        if(maxIndex >= 0 && maxIndex <= route.length)
        {
            var index = maxIndex
            if(index > route.length - 1)
            {
                index = route.length - 1
            }
            var point = route[Math.floor(index)];
            distance2 = point.distance
        }
        else
        if(route.length > 0)
        {
            var point = route[route.length - 1]
            distance2 = point.distance
            x2 = graphX1 + (route.length - minIndex) * graphW / (maxIndex - minIndex)
        }

		ctx.textAlign = "right";
        ctx.fillText(distanceToText(distance2 / M_TO_MI), 
            x2, 
            CANVAS_HEIGHT - FONT_MARGIN);


// middle points
		ctx.textAlign = "center";
// meters
        step = M_TO_MI  
        index = Math.floor(minIndex)
//console.log('distance1=' + distance1 / M_TO_MI + ' distance2=' + distance2 / M_TO_MI)
        if(index < 0)
        {
            index = 0
        }
        for(var i = distance1 + step; i < distance2 + step; i += step)
        {
// quantize the distance to the nearest step
            var scaler = 1 / step
            var distance = i * scaler
            distance = Math.floor(distance)
            distance /= scaler
            
// get the point at the distance
            while(index < route.length && 
                route[index].distance < distance)
            {
                index++
            }

//console.log('distance=' + distance / M_TO_MI)
// get the X of the point
            if(index < route.length)
            {
                var x = (index - minIndex) * graphW / (maxIndex - minIndex) + graphX1
                ctx.fillText(distanceToText(distance / M_TO_MI), 
                    x, 
                    CANVAS_HEIGHT - FONT_MARGIN);
		        ctx.beginPath();
		        ctx.moveTo(x, 0);
		        ctx.lineTo(x, WAVEFORM_HEIGHT);
		        ctx.stroke();
            }
        }


        ctx.beginPath()
        ctx.moveTo(0, WAVEFORM_HEIGHT)
        ctx.lineTo(canvas.width, WAVEFORM_HEIGHT)
        ctx.stroke()



// the path
		ctx.lineWidth = '2'
		for(var pass = 0; pass < 2; pass++)
		{
			ctx.beginPath();
			if(pass == 0)
				ctx.strokeStyle = "#FF0000";
			else
				ctx.strokeStyle = "#0000ff";
		
			for(var i = graphX1; i < graphX2; i++)
			{
				var result = xToPaceAltitude(i - graphX1);
				var y = 0;
				
				if(pass == 0)
				{
					y = paceToPixel(result.pace);
					ctx.strokeStyle = "#FF0000";
				}
				else
				{
					y = altToPixel(result.altitude);
					ctx.strokeStyle = "#0000ff";
				}

				if(i == 0)
				{
					ctx.moveTo(graphX1, y);
				}
				else
				{
					ctx.lineTo(i, y);
				}
			}

			ctx.stroke();
		}

		if(isTrackingCursor)
		{
			var result = xToPaceAltitude(cursorIndex);
//debug("drawGraph", "pace=" + result.pace + " altitude=" + result.altitude);
			y = paceToPixel(result.pace);
			
			ctx.strokeStyle = "#FF0000";
			drawCross(ctx, cursorIndex + graphX1, y);
			
			y = altToPixel(result.altitude);
			ctx.strokeStyle = "#0000FF";
			drawCross(ctx, cursorIndex + graphX1, y);
		}

// the heatmap colors
        if(isHeatmap)
        {
            ctx.lineWidth = '1'
            for(var i = 0; i < WAVEFORM_HEIGHT; i++)
            {
                var value = i / WAVEFORM_HEIGHT * 300
                var hue = 300 + value
                if(hue > 360)
                {
                    hue -= 360
                }
                
                ctx.strokeStyle = 'hsl(' + hue + ', 100%, 50%)'
                ctx.fillStyle = ctx.strokeStyle
                ctx.beginPath()
                ctx.moveTo(0, i)
                ctx.lineTo(HEATMAP_W, i)
                ctx.stroke()
            }
        }
        
        
	}
	
    function heatMapEvent()
    {
        isHeatmap = heatmapToggle.checked
        saveDefaults()
        drawGraph()
        drawMap(true, true, true)
    }
    
	function constrainEvent()
	{
//		debug("constrainEvent", "");
		if(document.getElementById("constrainDistance").checked)
		{
			constrain = FIXED_DISTANCE;
		}
		else
		{
			constrain = FIXED_TIME;
		}
		saveDefaults();
		redraw(true);
	}

	function timeEvent()
	{
		if($(absoluteTime).prop("checked") == true)
		{
			timeFormat = ABSOLUTE_TIME;
		}
		else
		{
			timeFormat = ELAPSED_TIME;
		}
		saveDefaults();
		redraw(true);
		updateOutput();
	}

	function analyzeURLArg(url)
	{
//		debug("analyzeURL 1", url);
		var client = new XMLHttpRequest();
		client.open("GET", url);
		client.onreadystatechange = function() 
		{
//			debug("analyzeURL", client.readyState);
			if(client.readyState == XMLHttpRequest.DONE)
			{
			  	analyze(client.responseText);
			}
		};
		client.send();	
	}

	function analyzeURL()
	{
		defaultURL = document.getElementById("url").value;
		debug("analyzeURL 2", defaultURL);
		saveDefaults();
		
		var client = new XMLHttpRequest();
		client.open("GET", defaultURL);
		client.onreadystatechange = function() 
		{
//			debug("analyzeURL", client.readyState);
			if(client.readyState == XMLHttpRequest.DONE)
			{
			  	analyze(client.responseText);
			}
		};
		client.send();	
	}
	
	function handleFileSelect(e)
	{
		analyzeFile();
	}
	
	function analyzeFile()
	{
		var files = document.getElementById('file').files;
		var reader = new FileReader();
		reader.readAsText(files[0]);
		reader.onloadend = function(evt)
		{
			if (evt.target.readyState == FileReader.DONE) 
			{
				analyze(evt.target.result);
			}
			
		}
	}


	function analyze(text)
	{

// get the coordinates
		var coords_begin = text.search("coordinates");
		var coords_end = text.search("/coordinates");
		var coordinates = text.slice(coords_begin + 13, coords_end - 1);
		var coordinates2 = coordinates.split("\n");
		var minLon = 180;
		var maxLon = -180
		var minLat = 180;
		var maxLat = -180;
		route = new Array();
//debug("analyze", "text=" + text);

		var point1;
		var accum = 0;
		var min_alt = 0;
		for(var i = 0; i < coordinates2.length /* && i < 64 */; i++)
		{
			var coordinate = coordinates2[i].split(",");
			if(coordinate.length == 3)
			{
				var llh = new LLH(parseFloat(coordinate[1]), 
					parseFloat(coordinate[0]), 
					parseFloat(coordinate[2]));
				if(llh.latitude > maxLat) maxLat = llh.latitude;
				if(llh.latitude < minLat) minLat = llh.latitude;
				if(llh.longitude > maxLon) maxLon = llh.longitude;
				if(llh.longitude < minLon) minLon = llh.longitude;
				if(llh.altitude < min_alt) min_alt = llh.altitude;

				var xyz = new llhToXYZ(llh).xyz;
				
				if(route.length > 0)
				{
					var distance = getDistance(xyz, point1.xyz);
					if(distance >= DISTANCE_INCREMENT)
					{
						accum += distance;
//debug("analyze", "accum=" + accum);
					}
					
					point2 = new RoutePoint(
						llh,
						xyz, 
						0,
						0,
						accum);

					if(distance >= DISTANCE_INCREMENT)
					{
						point1 = point2;
					}

					route.push(point2);
				}
				else
				{
					point1 = new RoutePoint(
						llh,
						xyz, 
						0,
						0,
						0);
					route.push(point1);
				}
			}

		}
debug("analyze", "min_alt=" + min_alt);

// Fix negative altitude
		for(var i = 0; i < route.length; i++)
		{
			route[i].llh.altitude += -min_alt;
		}

// update map
		boundaries = new google.maps.LatLngBounds(
			new google.maps.LatLng(minLat, minLon),
			new google.maps.LatLng(maxLat, maxLon));
		map.fitBounds(boundaries);


// get the timestamps
// get local timezone in ms
//				var time_zone = new Date().getTimezoneOffset() * 60 * 1000;
		var timestamps = text.slice(coords_end + 13);
		var timestamps_begin = timestamps.search("<Placemark>");
		var timestamps2 = timestamps.slice(timestamps_begin);
		var timestamps3 = timestamps2.split("\n");

//document.getElementById("text").innerHTML += "time zone=" + time_zone + "<BR>\n";
		for(var i = 0; i < timestamps3.length && i < route.length; i++)
		{
			var timestamp = timestamps3[i].split(">");
//console.log("analyze", "timestamp=" + timestamp);
			var begin = null;
			var elapsed = null;

			for(var j = 0; j < timestamp.length - 1; j++)
			{
				if(begin == null && timestamp[j].indexOf("begin") >= 0)
				{
					var beginText = timestamp[j + 1].split("<");
					begin = new Date(beginText[0]);
				}

				if(elapsed == null && timestamp[j].indexOf("Elapsed") >= 0)
				{
					var elapsedText = timestamp[j + 1].split("<");
					elapsed = elapsedText[0];
//console.log("analyze", "elapsedText=" + elapsedText);
				}
			}

//			begin.setTime(begin.getTime() + time_zone);
//			document.getElementById("text").innerHTML += 
//				begin.toUTCString() + "<BR>\n";

//			document.getElementById("text").innerHTML += 
//				"begin=" + timestamp[3].slice(0, 20) + 
//				" end=" + timestamp[5].slice(0, 20) + "<BR>\n";
// store time as UTC seconds
			if(begin != null) route[i].time = begin.getTime() / 1000;
			if(elapsed != null) route[i].elapsed = parseInt(elapsed);


//			debug("analyze", "time=" + begin.toUTCString() + " elapsed=" + elapsed);
		}



		minIndex = 0;
		maxIndex = route.length;
		highlightBegin = 0;
		highlightEnd = route.length;
		redraw(true);
		drawMap(true, true, true);
		updateOutput();
debug("analyze", 
	"length=" + route.length + 
	" minPace=" + minPace +
	" maxPace=" + maxPace + 
	" minAlt=" + minAlt +
	" maxAlt=" + maxAlt);
	}


	function loadDefaults()
	{
		var cookie = document.cookie.split(';');
		for(var i = 0; i < cookie.length; i++)
		{
			cookie[i] = cookie[i].trim();
		  	var row = cookie[i].split("=");
			if(row[0].indexOf("mapLatitude") == 0) mapLatitude = parseFloat(row[1]);
			else
			if(row[0].indexOf("mapLongitude") == 0) mapLongitude = parseFloat(row[1]);
			else
			if(row[0].indexOf("mapZoom") == 0) mapZoom = parseFloat(row[1]);
			else
			if(row[0].indexOf("mapMode") == 0) mapMode = row[1];
			else
			if(row[0].indexOf("smoothingTime") == 0) smoothingTime = parseInt(row[1]);
			else
			if(row[0].indexOf("smoothingDistance") == 0) smoothingDistance = parseFloat(row[1]);
			else
			if(row[0].indexOf("url") == 0) defaultURL = row[1];
			else
//			if(row[0].indexOf("constrain") == 0) constrain = parseInt(row[1]);
//			else
			if(row[0].indexOf("isHeatmap") == 0) isHeatmap = (row[1] == 'true');
			else
			if(row[0].indexOf("timeFormat") == 0) timeFormat = parseInt(row[1]);


//			debug("loadDefaults", row[0] + "=" + row[1]);
//			if(row[0].indexOf("minPace") == 0) minPace = parseInt(row[1]);
//			else
//			if(row[0].indexOf("maxPace") == 0) maxPace = parseInt(row[1]);
//			else
//			if(row[0].indexOf("minAlt") == 0) minAlt = parseInt(row[1]);
//			else
//			if(row[0].indexOf("maxAlt") == 0) maxAlt = parseInt(row[1]);
//			else

		}

		debug("loadDefaults", document.cookie);
//		debug("loadDefaults", defaultURL);
	}
	
	function setCookie(name, value) 
	{
        var date = new Date();
		var days = 60;
        date.setTime(date.getTime()+(days * 24 * 60 * 60 * 1000));
        var expires = "; expires=" + date.toGMTString();
	    document.cookie = name + "=" + value + expires;
	}

	function saveDefaults()
	{
		setCookie("mapLatitude", mapLatitude);
		setCookie("mapLongitude", mapLongitude);
		setCookie("mapZoom", mapZoom);
		setCookie("mapMode", mapMode);

//		setCookie("minPace", minPace);
//		setCookie("maxPace", maxPace);
//		setCookie("minAlt", minAlt);
//		setCookie("maxAlt", maxAlt);
		setCookie("smoothingTime", smoothingTime);
		setCookie("smoothingDistance", smoothingDistance);
		setCookie("url", defaultURL);
//		setCookie("constrain", constrain);
		setCookie("isHeatmap", isHeatmap);
		setCookie("timeFormat", timeFormat);
//		debug("saveDefaults", document.cookie);
	}


</script>







